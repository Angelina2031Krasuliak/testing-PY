<h3 align="center">Екзаменаційна робота</h3>
<h3 align="center"> з навчальної дисципліни</h3>
<h3 align="center"> «Тестування програмних систем та комплексів»</h3>
<h3 align="center"> студентки групи КНк-340 </h3>
<h3 align="center"> Красуляк Ангеліни Русланівни</h3>

---------------------------------------------------------------------------

<h2>Білет №8</h2>

### 1. **Що таке позитивне та негативне тестування? Наведіть приклади для форми логіну.**

**Позитивне тестування** — перевіряємо, що система працює правильно на коректних даних.

Приклади для логіну:
- Ввести правильний email + правильний пароль → успішний вхід, редірект у кабінет.
- Ввести email у правильному форматі (наприклад, user@gmail.com) → поле приймає значення, помилки немає.
- Ввести правильний пароль, що відповідає правилам (мін. довжина, символи) → вхід успішний.

**Негативне тестування** — перевіряємо, що система правильно обробляє неправильні/неочікувані дані (не ламається, показує помилки).

Приклади:
- Порожні поля → повідомлення “Заповніть поле email/пароль”.
- Невірний формат email (user@) → повідомлення “Некоректний email”.
- Правильний email, але неправильний пароль → “Невірні дані”.

- Дуже довгі рядки (1000 символів) → форма не падає, є валідація/обмеження.

- SQL/XSS-підстановка ` OR 1=1 --` `<script>` ввід екранується, вхід не виконується, система безпечна.
-----------------------------------------------------------------------------------------------------------
### 2. **Поясніть концепцію «Branching» (гілкування) у Git. Навіщо створювати окремі гілки для фіч та тестів?**

**Branching (гілкування) у Git** — це робота над змінами в окремій гілці без впливу на основну (зазвичай `main/master`).

**Кожна гілка — окрема “лінія розвитку” проєкту !!!**

Навіщо робити окремі гілки:
1. **Feature-branch (гілка під фічу):** `feature/login-form`
- щоб розробляти нову функцію ізольовано;
- легше робити code review через Pull Request;
- якщо фіча зламалась — main залишається стабільним.

2. **Test/CI branch або окрема гілка під тестові зміни:** 
`test/add-unit-tests`
- щоб додати/переробити тести, не змішуючи з логікою фічі;
- зручно експериментувати з CI (GitHub Actions) без ризику для основної гілки.
-----------------------------------------------------------------------------------------------------------------
### 3. **Як автоматизувати запуск тестів при кожному коміті (Commit) за допомогою GitHub Actions?**

**GitHub Actions** — це вбудований у GitHub механізм CI/CD, який дозволяє автоматично виконувати дії (збірку, тести, деплой) у відповідь на події в репозиторії.

Як це працює:
1. **Створюється workflow** (сценарій автоматизації) 
- У репозиторії додають файл у папку `.github/workflows/`. 
- Це інструкція, що саме потрібно запускати.
2. **Вказується подія-тригер**
- Щоб тести запускались на кожному коміті, обирають подію `push` — вона спрацьовує при кожному відправленні коміту в репозиторій (push).
- Часто також додають `pull_request`, щоб перевіряти тести перед злиттям у main.
3. **Створюється job (завдання) на віртуальному середовищі**
- Workflow запускає runner (віртуальний комп’ютер у хмарі: Linux/Windows/macOS).
- На ньому виконуються всі кроки тестування.
4. **Описуються steps (кроки виконання)**
- завантажити код репозиторію (checkout),
- встановити потрібну версію Python,
- встановити залежності проєкту (pip install),
- запустити тестовий фреймворк (pytest / unittest).
5. **Результат зберігається в GitHub**
- У вкладці Actions видно: успішно/помилка, логи, на якому кроці впало. Якщо тести падають — це сигнал, що коміт поламав функціональність або тести.

Навіщо це потрібно:
- автоматично ловить помилки одразу після коміту;
- гарантує, що в main (або в PR) потрапляє код, який проходить тести;
- економить час: не треба запускати все вручну щоразу;
- у команді всі бачать однаковий результат перевірки (єдиний стандарт).
----------------------------------------------------------------------------------------------------------------------
### 4. **Завдання: У файлі main.py створіть функцію list_to_set(input_list: list), яка перетворює список у множину (видаляє дублікати) і повертає її. Тест: У файлі test.py перевірте, чи дійсно дублікати зникають і чи повертається правильний тип даних.**

**Умова:** У файлі `main.py` створити функцію `list_to_set(input_list: list)`, яка перетворює список у множину (`set`), видаляє дублікати та повертає результат. У файлі `test.py` реалізувати модульні тести (unit-тести) за допомогою стандартної бібліотеки `unittest`, які перевіряють:
- що дублікати зникають;
- що повертається правильний тип даних (`set`).

---------------------------------------------------------------------------------------
### **Реалізація функції (`main.py`)**
```python
def list_to_set(input_list: list):
    """
    Перетворює список у множину (set),
    видаляючи дублікати.
    """
    return set(input_list)
```
---------------------------------------------------------------------------------------

### **Реалізація unit-тестів (`test.py`)**

```python
import unittest
from main import list_to_set


class TestListToSet(unittest.TestCase):

    def test_duplicates_removed(self):
        data = [1, 2, 2, 3, 4, 4, 5]
        result = list_to_set(data)
        self.assertEqual(result, {1, 2, 3, 4, 5})

    def test_return_type_is_set(self):
        data = [1, 1, 1]
        result = list_to_set(data)
        self.assertIsInstance(result, set)


if __name__ == "__main__":
    unittest.main()
```
---------------------------------------------------------------------------------------
### **Запуск тестів**

Тести запускаються командою:

```bash
python test.py
```
---

### Очікуваний результат

При успішному проходженні тестів у консолі відображається повідомлення:

```text
$ python test.py
..
----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK
```
### **Висновок**

Функція `list_to_set()` коректно перетворює список у множину, видаляючи дублікати. Модульні тести, реалізовані через `unittest`, підтверджують правильність результату та типу повернених даних.

